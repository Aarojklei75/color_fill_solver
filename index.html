<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title><!DOCTYPE html>
        <html lang="en">
        <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Color Fill Solver</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        canvas { border: 1px solid #000; display: block; margin: 20px 0; }
        #status { margin-top: 10px; font-style: italic; }
        #output { margin-top: 10px; white-space: pre-wrap; }
    </style>
</head>
<body>
<h1>Color Fill Puzzle Solver</h1>
<input type="file" id="upload" accept="image/*" />
<canvas id="canvas"></canvas>
<div id="status"></div>
<div id="output"></div>

<script>
    const upload = document.getElementById('upload');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const status = document.getElementById('status');
    const output = document.getElementById('output');

    const GRID_ROWS = 12;
    const GRID_COLS = 12;
    const COLORS = ['red','orange','green','blue','yellow','cyan','magenta'];

    function classifyColor(r, g, b) {
        if (r > 200 && g > 100 && g < 200 && b < 100) return 'orange';
        if (r > 200 && g < 100 && b < 100) return 'red';
        if (g > 200 && r < 100 && b < 100) return 'green';
        if (b > 200 && r < 100 && g < 100) return 'blue';
        if (r > 200 && g > 200 && b < 100) return 'yellow';
        if (r < 100 && g > 200 && b > 200) return 'cyan';
        if (r > 200 && g < 100 && b > 200) return 'magenta';
        const target = {
            red:[255,0,0],
            orange:[255,165,0],
            green:[0,255,0],
            blue:[0,0,255],
            yellow:[255,255,0],
            cyan:[0,255,255],
            magenta:[255,0,255]
        };
        let best = 'red';
        let distMin = Infinity;
        for (let c of COLORS) {
            const [cr, cg, cb] = target[c];
            const d = (r-cr)**2 + (g-cg)**2 + (b-cb)**2;
            if (d < distMin) { distMin = d; best = c; }
        }
        return best;
    }

    function getRegion(grid) {
        const startColor = grid[0][0];
        const visited = Array(GRID_ROWS).fill().map(() => Array(GRID_COLS).fill(false));
        const region = [];
        const stack = [[0,0]];
        while (stack.length) {
            const [r,c] = stack.pop();
            if (r < 0 || c < 0 || r >= GRID_ROWS || c >= GRID_COLS) continue;
            if (visited[r][c] || grid[r][c] !== startColor) continue;
            visited[r][c] = true;
            region.push([r,c]);
            stack.push([r+1,c],[r-1,c],[r,c+1],[r,c-1]);
        }
        return region;
    }

    function floodFillGrid(grid, color) {
        const newGrid = grid.map(row => row.slice());
        getRegion(grid).forEach(([r,c]) => newGrid[r][c] = color);
        return newGrid;
    }

    function isUniform(grid) {
        const first = grid[0][0];
        return grid.every(row => row.every(cell => cell === first));
    }

    // Beam search solver for improved performance
    function solveGrid(startGrid) {
        const key = g => g.map(r => r.join(',')).join(';');
        const beamWidth = 10;
        const maxDepth = 25;
        let beam = [{ grid: startGrid, seq: [], size: getRegion(startGrid).length }];
        const seen = new Set([key(startGrid)]);

        for (let depth = 0; depth < maxDepth; depth++) {
            const nextCandidates = [];
            for (const { grid, seq } of beam) {
                const current = grid[0][0];
                for (const color of COLORS) {
                    if (color === current) continue;
                    const nextGrid = floodFillGrid(grid, color);
                    const k = key(nextGrid);
                    if (seen.has(k)) continue;
                    seen.add(k);
                    const regionSize = getRegion(nextGrid).length;
                    nextCandidates.push({ grid: nextGrid, seq: [...seq, color], size: regionSize });
                }
            }
            if (!nextCandidates.length) break;
            // Sort by largest region size to focus on promising states
            nextCandidates.sort((a, b) => b.size - a.size);
            beam = nextCandidates.slice(0, beamWidth);
            for (const { grid, seq } of beam) {
                if (isUniform(grid)) return seq;
            }
        }
        // Return best sequence found (greedy fallback)
        return beam[0].seq;
    }

    upload.addEventListener('change', event => {
        const file = event.target.files[0];
        if (!file) return;
        const img = new Image();
        img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const data = ctx.getImageData(0, 0, img.width, img.height).data;
            output.textContent = `Loaded image size: ${img.width}x${img.height}\n`;
            const cellW = Math.floor(img.width / GRID_COLS);
            const cellH = Math.floor(img.height / GRID_ROWS);
            const grid = [];
            for (let r = 0; r < GRID_ROWS; r++) {
                const row = [];
                for (let c = 0; c < GRID_COLS; c++) {
                    let rSum = 0, gSum = 0, bSum = 0, count = 0;
                    for (let y = r * cellH; y < (r + 1) * cellH; y++) {
                        for (let x = c * cellW; x < (c + 1) * cellW; x++) {
                            const i = (y * img.width + x) * 4;
                            rSum += data[i];
                            gSum += data[i+1];
                            bSum += data[i+2];
                            count++;
                        }
                    }
                    row.push(classifyColor(
                        Math.round(rSum / count),
                        Math.round(gSum / count),
                        Math.round(bSum / count)
                    ));
                }
                grid.push(row);
            }
            output.textContent += 'Classified Grid:\n';
            grid.forEach(r => output.textContent += r.join(' | ') + '\n');
            status.textContent = 'Thinking...';
            setTimeout(() => {
                const solution = solveGrid(grid);
                status.textContent = '';
                output.textContent += solution ?
                    `Solution (${solution.length} moves): ${solution.join(', ')}` : 'No solution found';
            }, 50);
        };
        img.src = URL.createObjectURL(file);
    });
</script>
</body>
</html>
</title>
</head>
<body>

</body>
</html>