<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Color Fill Puzzle Solver</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        canvas { border: 1px solid #000; display: block; margin: 20px 0; }
        .color-step { display: inline-block; width: 30px; height: 30px; margin: 4px; border: 2px solid black; cursor: pointer; }
        #status { margin-top: 10px; font-style: italic; }
        #output { white-space: pre-wrap; }
    </style>
</head>
<body>
<h1>Interactive Color Fill Solver</h1>
<input type="file" id="upload" accept="image/*" />
<canvas id="canvas"></canvas>
<div id="status"></div>
<div id="output"></div>
<div id="steps"></div>

<script>
    const upload = document.getElementById('upload');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const status = document.getElementById('status');
    const output = document.getElementById('output');
    const stepsDiv = document.getElementById('steps');

    const GRID_ROWS = 12;
    const GRID_COLS = 12;
    const COLOR_DISTANCE_THRESHOLD = 50;

    let colorPalette = []; // Will hold actual RGB for each label
    let currentGrid = null;

    function colorDistance(c1, c2) {
        return Math.sqrt(
            (c1[0] - c2[0]) ** 2 +
            (c1[1] - c2[1]) ** 2 +
            (c1[2] - c2[2]) ** 2
        );
    }

    function groupColors(avgColors) {
        const clusters = [];
        const labels = [];

        for (const color of avgColors) {
            let found = false;
            for (let i = 0; i < clusters.length; i++) {
                if (colorDistance(color, clusters[i]) < COLOR_DISTANCE_THRESHOLD) {
                    labels.push(i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                clusters.push(color);
                labels.push(clusters.length - 1);
            }
        }
        return { clusters, labels };
    }

    function getRegion(grid, startR = 0, startC = 0) {
        const startColor = grid[startR][startC];
        const visited = Array(GRID_ROWS).fill().map(() => Array(GRID_COLS).fill(false));
        const region = [];
        const stack = [[startR, startC]];

        while (stack.length) {
            const [r, c] = stack.pop();
            if (r < 0 || c < 0 || r >= GRID_ROWS || c >= GRID_COLS) continue;
            if (visited[r][c] || grid[r][c] !== startColor) continue;
            visited[r][c] = true;
            region.push([r, c]);
            stack.push([r + 1, c], [r - 1, c], [r, c + 1], [r, c - 1]);
        }
        return region;
    }

    function floodFillGrid(grid, color) {
        const newGrid = grid.map(row => row.slice());
        getRegion(grid).forEach(([r, c]) => newGrid[r][c] = color);
        return newGrid;
    }

    function isUniform(grid) {
        const first = grid[0][0];
        return grid.every(row => row.every(cell => cell === first));
    }

    function solveGrid(startGrid) {
        const key = g => g.map(r => r.join(',')).join(';');
        const beamWidth = 10;
        const maxDepth = 25;
        let beam = [{ grid: startGrid, seq: [], size: getRegion(startGrid).length }];
        const seen = new Set([key(startGrid)]);

        for (let depth = 0; depth < maxDepth; depth++) {
            const nextCandidates = [];
            for (const { grid, seq } of beam) {
                const current = grid[0][0];
                const used = new Set([current]);
                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        const color = grid[r][c];
                        if (used.has(color)) continue;
                        used.add(color);
                        const nextGrid = floodFillGrid(grid, color);
                        const k = key(nextGrid);
                        if (seen.has(k)) continue;
                        seen.add(k);
                        const regionSize = getRegion(nextGrid).length;
                        nextCandidates.push({ grid: nextGrid, seq: [...seq, color], size: regionSize });
                    }
                }
            }
            if (!nextCandidates.length) break;
            nextCandidates.sort((a, b) => b.size - a.size);
            beam = nextCandidates.slice(0, beamWidth);
            for (const { grid, seq } of beam) {
                if (isUniform(grid)) return seq;
            }
        }
        return beam[0].seq;
    }

    function drawGrid(grid) {
        const cellW = canvas.width / GRID_COLS;
        const cellH = canvas.height / GRID_ROWS;
        for (let r = 0; r < GRID_ROWS; r++) {
            for (let c = 0; c < GRID_COLS; c++) {
                const label = grid[r][c];
                const [rVal, gVal, bVal] = colorPalette[label];
                ctx.fillStyle = `rgb(${rVal}, ${gVal}, ${bVal})`;
                ctx.fillRect(c * cellW, r * cellH, cellW, cellH);
            }
        }
    }

    upload.addEventListener('change', event => {
        const file = event.target.files[0];
        if (!file) return;
        const img = new Image();
        img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const data = ctx.getImageData(0, 0, img.width, img.height).data;

            const cellW = Math.floor(img.width / GRID_COLS);
            const cellH = Math.floor(img.height / GRID_ROWS);
            const avgColors = [];
            const gridRGB = [];

            for (let r = 0; r < GRID_ROWS; r++) {
                const row = [];
                for (let c = 0; c < GRID_COLS; c++) {
                    let rSum = 0, gSum = 0, bSum = 0, count = 0;
                    for (let y = r * cellH; y < (r + 1) * cellH; y++) {
                        for (let x = c * cellW; x < (c + 1) * cellW; x++) {
                            const i = (y * img.width + x) * 4;
                            rSum += data[i];
                            gSum += data[i + 1];
                            bSum += data[i + 2];
                            count++;
                        }
                    }
                    const avg = [
                        Math.round(rSum / count),
                        Math.round(gSum / count),
                        Math.round(bSum / count)
                    ];
                    avgColors.push(avg);
                    row.push(avg);
                }
                gridRGB.push(row);
            }

            const { clusters, labels } = groupColors(avgColors);
            colorPalette = clusters;
            output.textContent = `Detected ${clusters.length} unique colors\n`;

            const grid = [];
            let idx = 0;
            for (let r = 0; r < GRID_ROWS; r++) {
                const row = [];
                for (let c = 0; c < GRID_COLS; c++) {
                    row.push(labels[idx++]);
                }
                grid.push(row);
            }

            currentGrid = grid;
            drawGrid(currentGrid);
            output.textContent += 'Solving...\n';
            stepsDiv.innerHTML = '';
            status.textContent = 'Solving...';

            setTimeout(() => {
                const solution = solveGrid(grid);
                status.textContent = '';
                output.textContent += `Solution (${solution.length} moves): ${solution.join(', ')}\n`;

                let stepGrid = grid;
                stepsDiv.innerHTML = '';
                solution.forEach((colorLabel, index) => {
                    const color = colorPalette[colorLabel];
                    const btn = document.createElement('div');
                    btn.className = 'color-step';
                    btn.title = `Step ${index + 1}: Color ${colorLabel}`;
                    btn.style.backgroundColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                    btn.addEventListener('click', () => {
                        stepGrid = floodFillGrid(stepGrid, colorLabel);
                        currentGrid = stepGrid;
                        drawGrid(stepGrid);
                    });
                    stepsDiv.appendChild(btn);
                });
            }, 50);
        };
        img.src = URL.createObjectURL(file);
    });
</script>
</body>
</html>
